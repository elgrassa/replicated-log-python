# Test workflow for replicated log system
# Separate test suites for Iteration 1 and Iteration 2
# Always tests with 2 secondaries and 1 master
# Collects logs and uploads as artifacts

name: Test Replicated Log System

on:
  push:
    # Run on all branches
  pull_request:
    # Run on all pull requests
  workflow_dispatch:

jobs:
  test-iteration1:
    name: Iteration 1 - 2 Secondaries
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.12'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install requests pytest pyyaml

    - name: Install system tools
      run: |
        sudo apt-get update
        sudo apt-get install -y jq curl bc

    - name: Generate docker-compose.yml
      run: |
        export NUM_SECONDARIES=2
        export SECONDARY_DELAYS="0,500"
        python3 generate_compose.py
        cat docker-compose.yml

    - name: Build Docker images
      run: |
        # Retry build on transient Docker errors
        max_retries=3
        retry_count=0
        while [ $retry_count -lt $max_retries ]; do
          if docker compose build; then
            break
          fi
          retry_count=$((retry_count + 1))
          if [ $retry_count -lt $max_retries ]; then
            echo "Build failed, retrying ($retry_count/$max_retries)..."
            sleep 5
          else
            echo "Build failed after $max_retries attempts"
            exit 1
          fi
        done

    - name: Start services
      run: |
        docker compose up -d
        sleep 5
        docker compose ps

    - name: Wait for services to be ready
      run: |
        timeout=60
        elapsed=0
        ports="8000 8001 8002"
        
        while [ $elapsed -lt $timeout ]; do
          all_ready=true
          for port in $ports; do
            curl -sf http://localhost:$port/health > /dev/null || all_ready=false
          done
          [ "$all_ready" = true ] && break
          sleep 2
          elapsed=$((elapsed + 2))
        done
        
        curl -s http://localhost:8000/health | jq
        curl -s http://localhost:8001/health | jq
        curl -s http://localhost:8002/health | jq

    - name: Run Iteration 1 verification script
      id: verify
      continue-on-error: true
      run: |
        chmod +x scripts/verify.sh
        ./scripts/verify.sh > verify_results.txt 2>&1
        echo "exit_code=$?" >> $GITHUB_OUTPUT
      env:
        GITHUB_OUTPUT: ${{ github.output }}

    - name: Run Iteration 1 comprehensive test script
      id: test
      continue-on-error: true
      run: |
        chmod +x test_and_log.sh
        ./test_and_log.sh > test_results.txt 2>&1
        echo "exit_code=$?" >> $GITHUB_OUTPUT

    - name: Run Iteration 1 Python smoke tests
      id: pytest
      continue-on-error: true
      run: |
        pip install requests pytest
        pytest -v tests/smoke_test.py::test_health tests/smoke_test.py::test_blocking_and_consistency > pytest_results.txt 2>&1 || true
        echo "exit_code=$?" >> $GITHUB_OUTPUT

    - name: Collect logs
      if: always()
      run: |
        docker compose logs master > replicated_log_master.txt
        docker compose logs > replicated_log_all.txt
        docker compose logs secondary1 > replicated_log_secondary1.txt
        docker compose logs secondary2 > replicated_log_secondary2.txt
        echo "Collected logs:"
        ls -lh replicated_log_*.txt

    - name: Test results summary
      if: always()
      run: |
        echo "## Iteration 1 Test Results" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "Config: 2 secondaries, delays: 0,500" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        if [ -f verify_results.txt ]; then
          echo "### Verification" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          tail -15 verify_results.txt >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
        fi
        
        if [ -f test_results.txt ]; then
          echo "### Test Script" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          tail -20 test_results.txt >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
        fi
        
        if [ -f pytest_results.txt ]; then
          echo "### Pytest" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          cat pytest_results.txt >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
        fi
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "Logs uploaded as artifacts: replicated_log_*.txt" >> $GITHUB_STEP_SUMMARY

    - name: Upload test results and logs
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: iteration1-results-2-nodes
        path: |
          verify_results.txt
          test_results.txt
          pytest_results.txt
          replicated_log_master.txt
          replicated_log_all.txt
          replicated_log_secondary*.txt
        retention-days: 30
        if-no-files-found: warn
        compression-level: 6

    - name: Check test results
      run: |
        failed=0
        
        if [ -f verify_results.txt ] && ! grep -q "Consistent ✅" verify_results.txt; then
          echo "Verification failed"
          failed=1
        fi
        
        if [ -f test_results.txt ] && ! grep -q "✅ All nodes consistent!" test_results.txt; then
          echo "Test script failed"
          failed=1
        fi
        
        if [ -f pytest_results.txt ] && grep -q "FAILED\|ERROR" pytest_results.txt; then
          echo "Pytest failed"
          failed=1
        fi
        
        if [ $failed -eq 1 ]; then
          echo "Iteration 1 tests failed - check artifacts for logs"
          exit 1
        fi

    - name: Cleanup
      if: always()
      run: |
        docker compose down -v

  test-iteration2:
    name: Iteration 2 - 2 Secondaries
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.12'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install requests pytest pyyaml

    - name: Install system tools
      run: |
        sudo apt-get update
        sudo apt-get install -y jq curl bc

    - name: Generate docker-compose.yml
      run: |
        export NUM_SECONDARIES=2
        export SECONDARY_DELAYS="0,500"
        python3 generate_compose.py
        cat docker-compose.yml

    - name: Build Docker images
      run: |
        # Retry build on transient Docker errors
        max_retries=3
        retry_count=0
        while [ $retry_count -lt $max_retries ]; do
          if docker compose build; then
            break
          fi
          retry_count=$((retry_count + 1))
          if [ $retry_count -lt $max_retries ]; then
            echo "Build failed, retrying ($retry_count/$max_retries)..."
            sleep 5
          else
            echo "Build failed after $max_retries attempts"
            exit 1
          fi
        done

    - name: Start services
      run: |
        docker compose up -d
        sleep 5
        docker compose ps

    - name: Wait for services to be ready
      run: |
        timeout=60
        elapsed=0
        ports="8000 8001 8002"
        
        while [ $elapsed -lt $timeout ]; do
          all_ready=true
          for port in $ports; do
            curl -sf http://localhost:$port/health > /dev/null || all_ready=false
          done
          [ "$all_ready" = true ] && break
          sleep 2
          elapsed=$((elapsed + 2))
        done
        
        curl -s http://localhost:8000/health | jq
        curl -s http://localhost:8001/health | jq
        curl -s http://localhost:8002/health | jq

    - name: Run Iteration 2 shell tests
      id: test_iter2
      continue-on-error: true
      run: |
        chmod +x test_iteration2.sh
        ./test_iteration2.sh localhost > test_iter2_results.txt 2>&1
        echo "exit_code=$?" >> $GITHUB_OUTPUT

    - name: Run Iteration 2 pytest tests
      id: pytest_iter2
      continue-on-error: true
      run: |
        pip install requests pytest
        pytest -v tests/test_iteration2.py > pytest_iter2_results.txt 2>&1 || true
        echo "exit_code=$?" >> $GITHUB_OUTPUT

    - name: Run Iteration 2 concurrency tests
      id: concurrent
      continue-on-error: true
      run: |
        python3 test_iteration2_concurrent.py > concurrent_results.txt 2>&1
        echo "exit_code=$?" >> $GITHUB_OUTPUT

    - name: Run Iteration 2 smoke tests
      id: pytest_smoke
      continue-on-error: true
      run: |
        pip install requests pytest
        pytest -v tests/smoke_test.py::test_write_concern_w1 tests/smoke_test.py::test_write_concern_w2 tests/smoke_test.py::test_eventual_consistency > pytest_smoke_results.txt 2>&1 || true
        echo "exit_code=$?" >> $GITHUB_OUTPUT

    - name: Collect logs
      if: always()
      run: |
        echo "Collecting logs after test execution..."
        mkdir -p Iteration_2
        docker compose logs master > Iteration_2/replicated_log_master.txt
        docker compose logs > Iteration_2/replicated_log_all.txt
        docker compose logs secondary1 > Iteration_2/replicated_log_secondary1.txt
        docker compose logs secondary2 > Iteration_2/replicated_log_secondary2.txt
        echo ""
        echo "Collected logs in Iteration_2/:"
        ls -lh Iteration_2/replicated_log_*.txt
        echo ""
        echo "Log file sizes:"
        du -h Iteration_2/replicated_log_*.txt

    - name: Test results summary
      if: always()
      run: |
        echo "## Iteration 2 Test Results" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "Config: 2 secondaries, delays: 0,500" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        if [ -f test_iter2_results.txt ]; then
          echo "### Shell Tests" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          tail -30 test_iter2_results.txt >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
        fi
        
        if [ -f pytest_iter2_results.txt ]; then
          echo "### Pytest Tests" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          cat pytest_iter2_results.txt >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
        fi
        
        if [ -f concurrent_results.txt ]; then
          echo "### Concurrency Tests" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          tail -20 concurrent_results.txt >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
        fi
        
        if [ -f pytest_smoke_results.txt ]; then
          echo "### Smoke Tests" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          cat pytest_smoke_results.txt >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
        fi
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "Logs uploaded as artifacts in Iteration_2/ folder: replicated_log_*.txt" >> $GITHUB_STEP_SUMMARY

    - name: Upload test results and logs
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: iteration2-results-2-nodes
        path: |
          test_iter2_results.txt
          pytest_iter2_results.txt
          concurrent_results.txt
          pytest_smoke_results.txt
          Iteration_2/
        retention-days: 30
        if-no-files-found: warn
        compression-level: 6

    - name: Check test results
      run: |
        failed=0
        
        # Check exit codes from test steps (most reliable indicator)
        if [ "${{ steps.test_iter2.outputs.exit_code }}" != "0" ] && [ "${{ steps.test_iter2.outputs.exit_code }}" != "" ]; then
          echo "Iteration 2 shell tests failed (exit code: ${{ steps.test_iter2.outputs.exit_code }})"
          failed=1
        fi
        
        if [ "${{ steps.pytest_iter2.outputs.exit_code }}" != "0" ] && [ "${{ steps.pytest_iter2.outputs.exit_code }}" != "" ]; then
          echo "Iteration 2 pytest tests failed (exit code: ${{ steps.pytest_iter2.outputs.exit_code }})"
          failed=1
        fi
        
        if [ "${{ steps.concurrent.outputs.exit_code }}" != "0" ] && [ "${{ steps.concurrent.outputs.exit_code }}" != "" ]; then
          echo "Concurrency tests failed (exit code: ${{ steps.concurrent.outputs.exit_code }})"
          failed=1
        fi
        
        if [ "${{ steps.pytest_smoke.outputs.exit_code }}" != "0" ] && [ "${{ steps.pytest_smoke.outputs.exit_code }}" != "" ]; then
          echo "Smoke tests failed (exit code: ${{ steps.pytest_smoke.outputs.exit_code }})"
          failed=1
        fi
        
        # Also check pytest results for FAILED/ERROR in summary (backup check)
        # Only check the summary line, not individual test names or informational messages
        if [ -f pytest_iter2_results.txt ]; then
          # Check if there are actual failures in the summary (not just the word in test names)
          if grep -qiE "(\d+ failed|\d+ error)" pytest_iter2_results.txt; then
            echo "Iteration 2 pytest tests failed (found failures in summary)"
            failed=1
          fi
        fi
        
        if [ -f pytest_smoke_results.txt ]; then
          if grep -qiE "(\d+ failed|\d+ error)" pytest_smoke_results.txt; then
            echo "Smoke tests failed (found failures in summary)"
            failed=1
          fi
        fi
        
        # Check shell test results for critical failures only (not warnings or informational ❌)
        # Look for patterns that indicate actual test failures, not just informational messages
        if [ -f test_iter2_results.txt ]; then
          # Check for critical failure patterns (health check failures, script exit codes)
          if grep -qiE "(health check failed|exit code [1-9])" test_iter2_results.txt; then
            echo "Iteration 2 shell tests failed (found critical failure indicators)"
            failed=1
          fi
        fi
        
        # Check concurrency test results for critical failures
        if [ -f concurrent_results.txt ]; then
          if grep -qiE "(health check failed|exit code [1-9]|Traceback|Exception)" concurrent_results.txt; then
            echo "Concurrency tests failed (found critical failure indicators)"
            failed=1
          fi
        fi
        
        if [ $failed -eq 1 ]; then
          echo "Iteration 2 tests failed - check artifacts for logs"
          exit 1
        fi

    - name: Cleanup
      if: always()
      run: |
        docker compose down -v

  test-iteration3-self-check:
    name: Iteration 3 - Self-Check Acceptance Test
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.12'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install requests pytest pyyaml

    - name: Install system tools
      run: |
        sudo apt-get update
        sudo apt-get install -y jq curl bc

    - name: Generate docker-compose.yml
      run: |
        export NUM_SECONDARIES=2
        export SECONDARY_DELAYS="0,500"
        python3 generate_compose.py
        cat docker-compose.yml

    - name: Build Docker images
      run: |
        # Retry build on transient Docker errors
        max_retries=3
        retry_count=0
        while [ $retry_count -lt $max_retries ]; do
          if docker compose build; then
            break
          fi
          retry_count=$((retry_count + 1))
          if [ $retry_count -lt $max_retries ]; then
            echo "Build failed, retrying ($retry_count/$max_retries)..."
            sleep 5
          else
            echo "Build failed after $max_retries attempts"
            exit 1
          fi
        done

    - name: Start services (M + S1 only)
      run: |
        docker compose up -d
        sleep 3
        docker compose stop secondary2
        sleep 2
        docker compose ps

    - name: Wait for services to be ready
      run: |
        timeout=60
        elapsed=0
        ports="8000 8001"
        
        while [ $elapsed -lt $timeout ]; do
          all_ready=true
          for port in $ports; do
            curl -sf http://localhost:$port/health > /dev/null || all_ready=false
          done
          [ "$all_ready" = true ] && break
          sleep 2
          elapsed=$((elapsed + 2))
        done
        
        curl -s http://localhost:8000/health | jq
        curl -s http://localhost:8001/health | jq
        echo "✅ Master and Secondary1 are healthy"

    - name: Run Iteration 3 Self-Check Acceptance Test
      id: self_check
      continue-on-error: true
      run: |
        chmod +x test_iter3_self_check_ci.sh
        ./test_iter3_self_check_ci.sh localhost > self_check_results.txt 2>&1
        echo "exit_code=$?" >> $GITHUB_OUTPUT
      env:
        GITHUB_OUTPUT: ${{ github.output }}

    - name: Collect logs
      if: always()
      run: |
        echo "Collecting logs after test execution..."
        mkdir -p Iteration_3
        docker compose logs master > Iteration_3/replicated_log_master.txt
        docker compose logs > Iteration_3/replicated_log_all.txt
        docker compose logs secondary1 > Iteration_3/replicated_log_secondary1.txt
        docker compose logs secondary2 > Iteration_3/replicated_log_secondary2.txt
        echo ""
        echo "Collected logs in Iteration_3/:"
        ls -lh Iteration_3/replicated_log_*.txt
        echo ""
        echo "Log file sizes:"
        du -h Iteration_3/replicated_log_*.txt

    - name: Test results summary
      if: always()
      run: |
        echo "## Iteration 3 Self-Check Acceptance Test Results" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "Config: 2 secondaries, delays: 0,500" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "Test Scenario:" >> $GITHUB_STEP_SUMMARY
        echo "- Start M + S1" >> $GITHUB_STEP_SUMMARY
        echo "- send (Msg1, W=1) - Ok" >> $GITHUB_STEP_SUMMARY
        echo "- send (Msg2, W=2) - Ok" >> $GITHUB_STEP_SUMMARY
        echo "- send (Msg3, W=3) - Wait" >> $GITHUB_STEP_SUMMARY
        echo "- send (Msg4, W=1) - Ok" >> $GITHUB_STEP_SUMMARY
        echo "- Start S2" >> $GITHUB_STEP_SUMMARY
        echo "- Check messages on S2 - [Msg1, Msg2, Msg3, Msg4]" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        if [ -f self_check_results.txt ]; then
          echo "### Self-Check Test Results" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          tail -50 self_check_results.txt >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
        fi
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "Logs uploaded as artifacts in Iteration_3/ folder: replicated_log_*.txt" >> $GITHUB_STEP_SUMMARY

    - name: Upload test results and logs
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: iteration3-self-check-results
        path: |
          self_check_results.txt
          Iteration_3/
        retention-days: 30
        if-no-files-found: warn
        compression-level: 6

    - name: Check test results
      run: |
        failed=0
        
        # Check exit code from test step
        if [ "${{ steps.self_check.outputs.exit_code }}" != "0" ] && [ "${{ steps.self_check.outputs.exit_code }}" != "" ]; then
          echo "Self-check test failed (exit code: ${{ steps.self_check.outputs.exit_code }})"
          failed=1
        fi
        
        # Check for critical failure patterns in output
        if [ -f self_check_results.txt ]; then
          if grep -qiE "(FAIL|exit code [1-9]|not healthy)" self_check_results.txt; then
            echo "Self-check test failed (found critical failure indicators)"
            failed=1
          fi
          
          # Verify all steps passed
          if ! grep -q "Step 6 PASS: S2 has all messages in correct order" self_check_results.txt; then
            echo "Self-check test failed (Step 6 did not pass)"
            failed=1
          fi
        fi
        
        # Verify replication in secondary2 logs
        echo ""
        echo "Verifying replication in secondary2 logs..."
        if [ -f Iteration_3/replicated_log_secondary2.txt ]; then
          replications=$(grep "Replicated seq=" Iteration_3/replicated_log_secondary2.txt | grep -E "msg=(Msg1|Msg2|Msg3|Msg4)")
          for pattern in "seq=1 msg=Msg1 (pos=0)" "seq=2 msg=Msg2 (pos=1)" "seq=3 msg=Msg3 (pos=2)" "seq=4 msg=Msg4 (pos=3)"; do
            if ! echo "$replications" | grep -q "$pattern"; then
              echo "❌ Missing: Replicated $pattern"
              failed=1
            fi
          done
          [ $failed -eq 0 ] && echo "✅ All 4 messages replicated to S2: $replications"
        else
          echo "⚠️  Secondary2 log file not found"
          failed=1
        fi
        
        # Verify message order on S2 via GET /messages
        echo ""
        echo "Verifying message order on S2 via GET /messages..."
        if curl -sf http://localhost:8002/health >/dev/null 2>&1; then
          # Wait a bit for any final replication
          sleep 2
          
          # Get messages from S2
          s2_response=$(curl -s http://localhost:8002/messages)
          s2_messages=$(echo "$s2_response" | jq -c '.messages')
          
          echo "S2 messages: $s2_messages"
          
          # Extract test messages in order
          test_msgs=$(echo "$s2_messages" | jq '[.[] | select(. == "Msg1" or . == "Msg2" or . == "Msg3" or . == "Msg4")]')
          expected_order='["Msg1","Msg2","Msg3","Msg4"]'
          actual_order=$(echo "$test_msgs" | jq -c .)
          
          echo "Test messages extracted: $test_msgs"
          echo "Expected order: $expected_order"
          echo "Actual order:   $actual_order"
          
          if [ "$actual_order" == "$expected_order" ]; then
            echo "✅ Message order verified: S2 has [Msg1, Msg2, Msg3, Msg4] in correct order"
          else
            echo "❌ Message order mismatch on S2"
            echo "   Expected: $expected_order"
            echo "   Got:      $actual_order"
            failed=1
          fi
          
          # Also verify count
          count=$(echo "$test_msgs" | jq 'length')
          if [ "$count" -ne 4 ]; then
            echo "❌ Expected 4 messages on S2, found $count"
            failed=1
          fi
        else
          echo "⚠️  Secondary2 not accessible for message order verification"
          failed=1
        fi
        
        if [ $failed -eq 1 ]; then
          echo ""
          echo "Iteration 3 self-check test failed - check artifacts for logs"
          exit 1
        fi
        
        echo ""
        echo "✅ Iteration 3 self-check acceptance test PASSED"
        echo "✅ All messages replicated to secondary2 in correct order"
        echo "✅ Message order verified on S2: [Msg1, Msg2, Msg3, Msg4]"

    - name: Cleanup
      if: always()
      run: |
        docker compose down -v
